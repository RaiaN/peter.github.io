{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/chasing_ue4_level_sequence_bug/","result":{"data":{"site":{"siteMetadata":{"author":"Peter Leontev","title":"Peter Leontev - Entrepreneur & Game Tools & Tech Programmer","disqusID":"peterleontev"}},"mdx":{"id":"a10a0212-6faa-5c19-9499-746ec6204cb1","excerpt":"Intro Unreal Engine 4 Level Sequence provides a great way to make in-game cinematics with ease. However, results sometimes are not desireable performance-wiseâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Level Sequence Optimization Tweaks in Unreal Engine 4\",\n  \"date\": \"2020-09-20\",\n  \"description\": \"Fixing camera cut bug and tuning occlusion system\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Intro\")), mdx(\"p\", null, \"Unreal Engine 4 Level Sequence provides a great way to make in-game cinematics with ease. However, results sometimes are not desireable performance-wise. There are different reasons why this might happen, for example, high quality content, a lot of visible primitives in player frustrum but that is not all. Lets start look at facts that pop up during profiling.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"The history of the bug\")), mdx(\"p\", null, \"Lets look at a very simple test scene with a plane, 1000 static mesh objects placed behind it and no lighting actors (only HDRI backdrop). Expected behaviour is that the engine will occlusion cull 1000 static meshes as they are located begind the plane. \"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1200px\"\n    }\n  }), \"\\n      \", mdx(\"a\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/f71e0b1af659926ef5cf57b031b27964/29114/occlusion_culling_test_scene.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"56.333333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACPklEQVQoz2NgYGBgZGQEkgEBAY2NjZWVldXV1bW1DTW19f39E1evXb9u/aYpU6c1NDbV1dblgkFqaioXFxcDBDAzMwPJlJSUQ4cObd26dfueg3v2Hdi/f/+ePbu379i+ffu2HTt37Nmz59Sp05cuXd6xY8fMmTPZ2NhRNHt5ee3Yvm3jlh2bNm/bDkRbtu/cunP3tt17gGjzni0bt6xevfrQocO3bt8pKytjgAMmJiYgaWpismfv/u279+zauKP3+AT/OyGJ11PTr2VH34jvOzZh1a5VWzdvXbFi+bNnL9ra2uFWQv2sqKi4Y9+RrVu3bdq+yft+gMwbZeU3GkYvzd0ee6m91LV56NR9vGflqhXHjh8/e/4CNzc31GaIZlFxyb3HzuzYunPDzk15N4pCH8RE3U/Ivl2w4uiqxgst8bfTek71A0Nk/foNb95+9PX1R3G2vqHxrPnzJk3uWL9pybLNcxZvnb5s64yVm2etWjNvzYpFS1fMnr1wUt/k9rCYwGOnzzW3dqLYzMvLFxLl0zQhoW1WYtu0xM6pSV3TU7umJ7dMia3vT2juT63pjMurC/WNswhPDs/JL0aEGUS/vLJ097T8KXMLJk4vmDKjrG96WdOkzMaJiWXdEWUd4TV9ETV9UUVNwQ5eFvKKSgzIAKJfVV0uryikszere1JBfX92TU9Sw4SY0o7whBKP2Cy3jFIvd18zQRFBBpyAkSEw2rZ5YkpFe1J1Z3x9X3hld2hSqadHuLmhqToLCwvcJgDLQgNRxqIV5wAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Occluded objects being rendered by using console command r.VisualizeOccludedPrimitives = 1\",\n    \"title\": \"Occluded objects being rendered by using console command r.VisualizeOccludedPrimitives = 1\",\n    \"src\": \"/static/f71e0b1af659926ef5cf57b031b27964/c1b63/occlusion_culling_test_scene.png\",\n    \"srcSet\": [\"/static/f71e0b1af659926ef5cf57b031b27964/5a46d/occlusion_culling_test_scene.png 300w\", \"/static/f71e0b1af659926ef5cf57b031b27964/0a47e/occlusion_culling_test_scene.png 600w\", \"/static/f71e0b1af659926ef5cf57b031b27964/c1b63/occlusion_culling_test_scene.png 1200w\", \"/static/f71e0b1af659926ef5cf57b031b27964/d61c2/occlusion_culling_test_scene.png 1800w\", \"/static/f71e0b1af659926ef5cf57b031b27964/29114/occlusion_culling_test_scene.png 1920w\"],\n    \"sizes\": \"(max-width: 1200px) 100vw, 1200px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"Now lets create a very simple level sequence where camera switches from game to sequence one and back but its position, rotation and other view parameters are not changed. \"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1200px\"\n    }\n  }), \"\\n      \", mdx(\"a\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/1c484c97f49b9199580cc03838a51d18/29114/level_sequence_example.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"56.333333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABHUlEQVQoz82Nb0+DMBCH+3GkpS2wEKfQQgdjgCNZYGwa5r8YExNeMPj+LzxgRNH43idPLrnr/a5o5S/FjaVcG/QdWzo24/QKa/en8uXtdKz27x+vhsmwTgjVJwkmGETPO/mQ2mVkHjbWcWMe75b22l9EKjztw6cDGDyW12loBp619q1wcN27CH3kCP92pscMg3IulfLUqnelDNMklOqM/RB5Un5XCsEYo5QKKeSkwTkhRP8FknPELHzh34a9gUuY/hmmA19h2HYmXNeFCnsYY8ftW1f0GIzBZJxrmkYmUBAEWZbtBrbbbZIkEIHfNgNRFCmlrAk4DU+c87FFVVU1TdO2bdd1UM/nM7RjHanrGu6maQp38zwviiKO42TgE2dXmkkQNNosAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Example of level sequence\",\n    \"title\": \"Example of level sequence\",\n    \"src\": \"/static/1c484c97f49b9199580cc03838a51d18/c1b63/level_sequence_example.png\",\n    \"srcSet\": [\"/static/1c484c97f49b9199580cc03838a51d18/5a46d/level_sequence_example.png 300w\", \"/static/1c484c97f49b9199580cc03838a51d18/0a47e/level_sequence_example.png 600w\", \"/static/1c484c97f49b9199580cc03838a51d18/c1b63/level_sequence_example.png 1200w\", \"/static/1c484c97f49b9199580cc03838a51d18/d61c2/level_sequence_example.png 1800w\", \"/static/1c484c97f49b9199580cc03838a51d18/29114/level_sequence_example.png 1920w\"],\n    \"sizes\": \"(max-width: 1200px) 100vw, 1200px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"Although one expects nothing bad should happen (right?) \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"there is an issue\"), \". Lets look at the image below to get more insights.\"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1200px\"\n    }\n  }), \"\\n      \", mdx(\"a\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/7d3515dc18b44ceb0280188d1f579f3b/29114/profiling_stats_1.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"56.333333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB80lEQVQoz4WQy27TQBSGvUvSfeNNm1S9iEpdVKpIUaGx61ShjTO2YxybXMiFmNiesceTS1MaJ4UtElvegAfgAdhAEqgEQbwS4wYqwoZfn36dc2bmHJ1hzKb9avR60Otd9AcWtHFbqjwzdL2oaEpBLzxRJVWT1SJFWVDQZKNSJBgjBzLZ0+xTXYcO7A66yIct27KgZcO2g2yHnt8aXAYh1CEdH2PmPCcapUqz+bxDsI/dLsEEe4Q6TX3sE39JJKxRYTrZdZmy+vjttXvZ8zwvLIXysP8/hY8RYmQgqtKZiyDpdG9bE8/F3l9y3aVg4fQmdUYEUkHVoGMh54Xj2NBpDy+7o+BqOHwZBFfBeDj+TbDgehyMRkOMXctqMwBIeSCb9ZLd1Iu6UasYXkNp1Gv1Wq1Rr5umCR3a07oD0dy2TbNVLpUYIMlUx4JwJGSOBOE4mz3k+UOOo34/nT45z53mAQ1SHBeS5h5mMpQHPP9IEOjOclZW3uztfWXjn6LRSSQyjUb/YRaLfYnFZisrs0jk8+rqZG3thmU/7OwwiiQXypV3qdTPg4Obe7s/ksn5xsb3RCIkmaR8W1+fxOMzlp2y7DyRmO/vf9zamm5uvt/eZqrVKv06SIjV693R/oPV77cIOdM0QZJ4AHK6LhoGn8+fACCI4i9RU/RoTFx60AAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Profiling stats, render thread hitches\",\n    \"title\": \"Profiling stats, render thread hitches\",\n    \"src\": \"/static/7d3515dc18b44ceb0280188d1f579f3b/c1b63/profiling_stats_1.png\",\n    \"srcSet\": [\"/static/7d3515dc18b44ceb0280188d1f579f3b/5a46d/profiling_stats_1.png 300w\", \"/static/7d3515dc18b44ceb0280188d1f579f3b/0a47e/profiling_stats_1.png 600w\", \"/static/7d3515dc18b44ceb0280188d1f579f3b/c1b63/profiling_stats_1.png 1200w\", \"/static/7d3515dc18b44ceb0280188d1f579f3b/d61c2/profiling_stats_1.png 1800w\", \"/static/7d3515dc18b44ceb0280188d1f579f3b/29114/profiling_stats_1.png 1920w\"],\n    \"sizes\": \"(max-width: 1200px) 100vw, 1200px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"Profiling stats indicate that two render thread hitches are present and what is important that is exactly the number of times camera switches when playing the level sequence. Looking more at stats it seems that render thread hitches caused by \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"~50ms occlusion cull\"), \"... which is strange as camera transform didn't change at all! Lets add \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Occluded primitives\"), \" graph to the image.\"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1200px\"\n    }\n  }), \"\\n      \", mdx(\"a\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/0ed344b78fb207cf9fe7d0840459fece/0f98f/profiling_stats_2.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"56.333333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwT/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABzyJK5QH/xAAaEAEAAgMBAAAAAAAAAAAAAAABABECEBIi/9oACAEBAAEFAhK8yyckyDX/xAAVEQEBAAAAAAAAAAAAAAAAAAAAIf/aAAgBAwEBPwGI/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFhAAAwAAAAAAAAAAAAAAAAAAACBB/9oACAEBAAY/AiL/AP/EABsQAAMAAgMAAAAAAAAAAAAAAAABERAhQVGR/9oACAEBAAE/IWkr9L2EuUKC0JSLH//aAAwDAQACAAMAAAAQCO//xAAWEQADAAAAAAAAAAAAAAAAAAABEGH/2gAIAQMBAT8Qop//xAAVEQEBAAAAAAAAAAAAAAAAAAAAIf/aAAgBAgEBPxCq/8QAGhABAAMAAwAAAAAAAAAAAAAAAQARITFhkf/aAAgBAQABPxAY9UwuTiKuom48RmoXFRayf//Z')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Profilig stats, number of occluded primitives drops to 0\",\n    \"title\": \"Profilig stats, number of occluded primitives drops to 0\",\n    \"src\": \"/static/0ed344b78fb207cf9fe7d0840459fece/e5166/profiling_stats_2.jpg\",\n    \"srcSet\": [\"/static/0ed344b78fb207cf9fe7d0840459fece/f93b5/profiling_stats_2.jpg 300w\", \"/static/0ed344b78fb207cf9fe7d0840459fece/b4294/profiling_stats_2.jpg 600w\", \"/static/0ed344b78fb207cf9fe7d0840459fece/e5166/profiling_stats_2.jpg 1200w\", \"/static/0ed344b78fb207cf9fe7d0840459fece/d9c39/profiling_stats_2.jpg 1800w\", \"/static/0ed344b78fb207cf9fe7d0840459fece/0f98f/profiling_stats_2.jpg 1920w\"],\n    \"sizes\": \"(max-width: 1200px) 100vw, 1200px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"In turns out that zero objects being occluded when camera switches from a game to cinematic one and back. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"As a result the engine renders all 1000 static meshes objects behind the plane\"), \". Really bad, right? Lets dive into the engine code.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Chasing root cause of the bug\")), mdx(\"p\", null, \"Go to SceneVisibility.cpp function called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FetchVisibilityForPrimitives_Range\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"static void FetchVisibilityForPrimitives_Range(FVisForPrimParams& Params, FGlobalDynamicVertexBuffer* DynamicVertexBufferIfSingleThreaded)\\n\")), mdx(\"p\", null, \"One branch of the function above can make the engine renderer completely ignore occlusion history for primitives:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"if (View.bIgnoreExistingQueries)\\n{\\n    // If the view is ignoring occlusion queries, the primitive is definitely unoccluded.\\n    // already set bIsOccluded = false;\\n    bOcclusionStateIsDefinite = View.bDisableQuerySubmissions;\\n}\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"bIgnoreExistingQueries\"), \" can be set to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"true\"), \" only during \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FSceneRenderer::PreVisibilityFrameSetup(...)\"), \" execution:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"// HighResScreenshot should get best results so we don't do the occlusion optimization based on the former frame\\nextern bool GIsHighResScreenshot;\\nconst bool bIsHitTesting = ViewFamily.EngineShowFlags.HitProxies;\\n// Don't test occlusion queries in collision viewmode as they can be bigger then the rendering bounds.\\nconst bool bCollisionView = ViewFamily.EngineShowFlags.CollisionVisibility || ViewFamily.EngineShowFlags.CollisionPawn;\\nif (GIsHighResScreenshot || !DoOcclusionQueries(FeatureLevel) || bIsHitTesting || bCollisionView)\\n{\\n    View.bDisableQuerySubmissions = true;\\n    View.bIgnoreExistingQueries = true;\\n}\\n\\n// ...\\nconst float DeltaTime = View.Family->CurrentRealTime - ViewState->LastRenderTime;\\nconst bool bFirstFrameOrTimeWasReset = DeltaTime < -0.0001f || ViewState->LastRenderTime < 0.0001f;\\n// ...\\n// detect conditions where we should reset occlusion queries\\nif (bFirstFrameOrTimeWasReset || \\n    ViewState->LastRenderTime + GEngine->PrimitiveProbablyVisibleTime < View.Family->CurrentRealTime ||\\n    View.bCameraCut ||\\n    View.bForceCameraVisibilityReset ||\\n    IsLargeCameraMovement(\\n        View, \\n        ViewState->PrevViewMatrixForOcclusionQuery, \\n        ViewState->PrevViewOriginForOcclusionQuery, \\n        GEngine->CameraRotationThreshold, GEngine->CameraTranslationThreshold))\\n{\\n    View.bIgnoreExistingQueries = true;\\n    View.bDisableDistanceBasedFadeTransitions = true;\\n}\\n\")), mdx(\"p\", null, \"The first set of conditions is not related to the bug since making high resolution screenshots, occlusion queries mechanism being disabled, performing hit testing or drawing collision do not happen when playing the level sequence.\"), mdx(\"p\", null, \"The second set is more interesting though as it covers the following conditions:\"), mdx(\"p\", null, \"1) The first frame OR the time was reset\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"bFirstFrameOrTimeWasReset\\n\")), mdx(\"p\", null, \"2) Primitive is not visible anymore \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"ViewState->LastRenderTime + GEngine->PrimitiveProbablyVisibleTime < View.Family->CurrentRealTime\\n\\n// The amount of time a primitive is considered to be probably visible after it was last actually visible. \\nUPROPERTY(config)\\nfloat PrimitiveProbablyVisibleTime;\\n\\n// Clear primitives which haven't been visible recently out of the occlusion history, and reset old pending occlusion queries.\\nViewState->TrimOcclusionHistory(ViewFamily.CurrentRealTime, ViewFamily.CurrentRealTime - GEngine->PrimitiveProbablyVisibleTime, ViewFamily.CurrentRealTime, ViewState->OcclusionFrameCounter);\\n\")), mdx(\"p\", null, \"3) Camera cut \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"/** Whether we did a camera cut for this view this frame. */\\nView.bCameraCut\\n\\n// Was there a camera cut this frame?\\nViewInitOptions.bInCameraCut = PlayerController->PlayerCameraManager->bGameCameraCutThisFrame;\\n\")), mdx(\"p\", null, \"4) Movie pipeline rendering (deferred passes): \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"View.bForceCameraVisibilityReset\\n\\n// Object Occlusion/Histories\\n{\\n    // If we're using tiling, we force the reset of histories each frame so that we don't use the previous tile's\\n    // object occlusion queries, as that causes things to disappear from some views.\\n    if(InSampleState.GetTileCount() > 1)\\n    {\\n        View->bForceCameraVisibilityReset = true;\\n    }\\n}\\n\")), mdx(\"p\", null, \"5) Large camera movement\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"IsLargeCameraMovement(View, ViewState->PrevViewMatrixForOcclusionQuery, ViewState->PrevViewOriginForOcclusionQuery, GEngine->CameraRotationThreshold, GEngine->CameraTranslationThreshold)\\n\\n/**\\n * Helper for InitViews to detect large camera movement, in both angle and position.\\n */\\nstatic bool IsLargeCameraMovement(FSceneView& View, const FMatrix& PrevViewMatrix, const FVector& PrevViewOrigin, float CameraRotationThreshold, float CameraTranslationThreshold)\\n{\\n    float RotationThreshold = FMath::Cos(FMath::DegreesToRadians(CameraRotationThreshold));\\n    float ViewRightAngle = View.ViewMatrices.GetViewMatrix().GetColumn(0) | PrevViewMatrix.GetColumn(0);\\n    float ViewUpAngle = View.ViewMatrices.GetViewMatrix().GetColumn(1) | PrevViewMatrix.GetColumn(1);\\n    float ViewDirectionAngle = View.ViewMatrices.GetViewMatrix().GetColumn(2) | PrevViewMatrix.GetColumn(2);\\n\\n    FVector Distance = FVector(View.ViewMatrices.GetViewOrigin()) - PrevViewOrigin;\\n    return \\n        ViewRightAngle < RotationThreshold ||\\n        ViewUpAngle < RotationThreshold ||\\n        ViewDirectionAngle < RotationThreshold ||\\n        Distance.SizeSquared() > CameraTranslationThreshold * CameraTranslationThreshold;\\n}\\n\")), mdx(\"p\", null, \"To figure out what causes \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"bIgnoreExistingQueries\"), \" to be true more stats have been added to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FSceneRenderer::PreVisibilityFrameSetup(...)\"), \". It turns out that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"View.bCameraCut = true\"), \" when level sequence both starts and ends.\"), mdx(\"p\", null, \"Lets look at the corresponding code again:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"// Was there a camera cut this frame?\\nViewInitOptions.bInCameraCut = PlayerController->PlayerCameraManager->bGameCameraCutThisFrame;\\n\\n// True if we did a camera cut this frame. Automatically reset to false every frame.\\n// This flag affects various things in the renderer (such as whether to use the occlusion queries from last frame, and motion blur).\\nUPROPERTY(Transient, BlueprintReadOnly, Category=PlayerCameraManager)\\nuint32 bGameCameraCutThisFrame : 1;\\n\\n//Sets the bGameCameraCutThisFrame flag to true (indicating we did a camera cut this frame; useful for game code to call, e.g., when performing a teleport that should be seamless) */\\nUFUNCTION(BlueprintCallable, Category = \\\"Camera\\\")\\nvoid SetGameCameraCutThisFrame() { bGameCameraCutThisFrame = true; }\\n\")), mdx(\"p\", null, \"There are many places in code where \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"SetGameCameraCutThisFrame()\"), \" is called:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"D:\\\\Unreal Engine\\\\UE_4.25\\\\Engine\\\\Source\\\\Developer\\\\FunctionalTesting\\\\Private\\\\ScreenshotFunctionalTest.cpp(50):            PlayerController->PlayerCameraManager->SetGameCameraCutThisFrame();\\nD:\\\\Unreal Engine\\\\UE_4.25\\\\Engine\\\\Source\\\\Editor\\\\Sequencer\\\\Private\\\\Sequencer.cpp(3463):                PC->PlayerCameraManager->SetGameCameraCutThisFrame();\\nD:\\\\Unreal Engine\\\\UE_4.25\\\\Engine\\\\Source\\\\Editor\\\\Sequencer\\\\Private\\\\Sequencer.cpp(3507):        PC->PlayerCameraManager->SetGameCameraCutThisFrame();\\nD:\\\\Unreal Engine\\\\UE_4.25\\\\Engine\\\\Source\\\\Runtime\\\\Engine\\\\Classes\\\\Camera\\\\PlayerCameraManager.h(881):    void SetGameCameraCutThisFrame() { bGameCameraCutThisFrame = true; }\\nD:\\\\Unreal Engine\\\\UE_4.25\\\\Engine\\\\Source\\\\Runtime\\\\Engine\\\\Private\\\\Interpolation.cpp(6765):                      PC->PlayerCameraManager->SetGameCameraCutThisFrame();\\nD:\\\\Unreal Engine\\\\UE_4.25\\\\Engine\\\\Source\\\\Runtime\\\\LevelSequence\\\\Private\\\\LevelSequencePlayer.cpp(258):              PC->PlayerCameraManager->SetGameCameraCutThisFrame();\\nD:\\\\Unreal Engine\\\\UE_4.25\\\\Engine\\\\Source\\\\Runtime\\\\LevelSequence\\\\Private\\\\LevelSequencePlayer.cpp(363):      PC->PlayerCameraManager->SetGameCameraCutThisFrame();\\n\")), mdx(\"p\", null, \"Last two \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"SetGameCameraCutThisFrame()\"), \" is what makes a drop in the number of occluded primitives to zero as it is being called from all over the place in Level sequence code.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Fixing the bug\")), mdx(\"p\", null, \"There are two easy/\\\"hack\\\" approaches to resolve this issue. The first one is about completely disabling camera cuts via the level sequence player actor settings, which can be done by selecting a level sequence player actor and setting \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"bDisableCameraCuts\"), \" UI property to false:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"// Disable camera cuts\\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\\\"Cinematic\\\")\\nuint32 bDisableCameraCuts : 1;\\n\")), mdx(\"p\", null, \"The second approach, which allows more control over camera cuts, is to call \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"SetDisableCameraCuts(...)\"), \" that belongs to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UMovieSceneSequencePlayer\"), \" actor:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"/** Set whether to disable camera cuts */\\nUFUNCTION(BlueprintCallable, Category=\\\"Game|Cinematic\\\")\\nvoid SetDisableCameraCuts(bool bInDisableCameraCuts) { PlaybackSettings.bDisableCameraCuts = bInDisableCameraCuts; }\\n\")), mdx(\"p\", null, \"The result is below:\\n\", mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1200px\"\n    }\n  }), \"\\n      \", mdx(\"a\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/b40ad3a3d8ce7cb05ea7098a197185a0/29114/profiling_stats_3.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"56.333333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAByElEQVQoz4WRWW/aQBSF/UeiOm95iCKyPRjjsSmLqTcwRWnAKxjjdcasAS+R2rRv/dOdMW3UPvXom6Nzr+7VSDPURJykkul1h25n5HZH1VDy+yOno894yQSyxUkGdkCyyeGSeB0koz2gOpww6Sv+zI08uHTihZ1gj5wodpLEjeAiSBcBcS88BzgnoHmQzFfUQJafDNNdeuvNBiKEMgSz+mQZzBBaZ5BwDqiGdNAmSxCkpnr/52ty3EGI9xBZJ0rRf5WmKTVU5LEqxlFA6iRJiWAa4/OXzn3svweI4jimZFnThvp6s86L08spP+Z5URxPp+KYE/KixBRVVZQ11WtRqyzLw+FAKYqqKJq/MGPf/DKzXNeK52PLsQ3Lthxn7i1XYegHmKD2MAjDVY1l23hZU1WtDcBHjsP0BaHNtgSWbbMszzBSr6cOBnyTEZrNGqbLgy4AeEBotcjNn1TNY5i3x8fT1VV+cVHSH0qaPlNdXv4DTX+9uXm7u/t2ff1dEKjP48nT83Os6z+m05deb8/zGcsG9/fhw8M7y0ZjdXuL8RuNhGUhACmewcuGYez3+91uhx9gX4Pz5o+22y3+BVEUWxzHAYB5F278Artd7XdfIREIAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Profilig stats, number of occluded primitives never drops to 0\",\n    \"title\": \"Profilig stats, number of occluded primitives never drops to 0\",\n    \"src\": \"/static/b40ad3a3d8ce7cb05ea7098a197185a0/c1b63/profiling_stats_3.png\",\n    \"srcSet\": [\"/static/b40ad3a3d8ce7cb05ea7098a197185a0/5a46d/profiling_stats_3.png 300w\", \"/static/b40ad3a3d8ce7cb05ea7098a197185a0/0a47e/profiling_stats_3.png 600w\", \"/static/b40ad3a3d8ce7cb05ea7098a197185a0/c1b63/profiling_stats_3.png 1200w\", \"/static/b40ad3a3d8ce7cb05ea7098a197185a0/d61c2/profiling_stats_3.png 1800w\", \"/static/b40ad3a3d8ce7cb05ea7098a197185a0/29114/profiling_stats_3.png 1920w\"],\n    \"sizes\": \"(max-width: 1200px) 100vw, 1200px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Code solution (the only one)\")), mdx(\"p\", null, \"As one may notice issue with number of occluded primitives is not fixed, it is just hidden by disabling camera cuts. Why? Real reason is that the engine must not ignore occlusion history if there was no large camera movement! Additionally, camera cut condition (3rd one above) must always take that into account.\"), mdx(\"p\", null, \"This is how the proper solution might look like:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"\\nconst bool bIsLargeCameraMovement = IsLargeCameraMovement(\\n    View, \\n    ViewState->PrevViewMatrixForOcclusionQuery, \\n    ViewState->PrevViewOriginForOcclusionQuery, \\n    GEngine->CameraRotationThreshold, GEngine->CameraTranslationThreshold\\n);\\n\\n// detect conditions where we should reset occlusion queries\\n// completely ignore camera cut condition here\\nif (bFirstFrameOrTimeWasReset || \\n    ViewState->LastRenderTime + GEngine->PrimitiveProbablyVisibleTime < View.Family->CurrentRealTime ||\\n    // View.bCameraCut, \\n    View.bForceCameraVisibilityReset ||\\n    bIsLargeCameraMovement)\\n{\\n    View.bIgnoreExistingQueries = true;\\n    View.bDisableDistanceBasedFadeTransitions = true;\\n}\\n\")), mdx(\"p\", null, \"Furthermore, one may think of adding a new variable to level sequence code or engine config that forces camera cut to happen ignoring \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IsLargeCameraMovement(...)\"), \" condition completely.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Bonus: more performance tweaks for level sequence\")), mdx(\"p\", null, \"The following engine variables give more control over occlusion culling system:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"UCLASS(abstract, config=Engine, defaultconfig, transient)\\nclass ENGINE_API UEngine\\n{\\n    // camera rotation (deg) beyond which occlusion queries are ignored from previous frame (because they are likely not valid)\\n    UPROPERTY(config)\\n    float CameraRotationThreshold;\\n\\n    // camera movement beyond which occlusion queries are ignored from previous frame (because they are likely not valid)\\n    UPROPERTY(config)\\n    float CameraTranslationThreshold;\\n\\n    // The amount of time a primitive is considered to be probably visible after it was last actually visible\\n    UPROPERTY(config)\\n    float PrimitiveProbablyVisibleTime;\\n}\\n\")), mdx(\"p\", null, \"Given spare memory resources, increasing \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"CameraRotationThreshold\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"CameraTranslationThreshold\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"PrimitiveProbablyVisibleTime\"), \" values might help with reducing occlusion culling time. \"), mdx(\"p\", null, \"Enjoy!\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Level Sequence Optimization Tweaks in Unreal Engine 4","date":"September 20, 2020","description":"Fixing camera cut bug and tuning occlusion system"}}},"pageContext":{"slug":"/blog/chasing_ue4_level_sequence_bug/","previous":{"fields":{"slug":"/blog/unreal_cast/"},"frontmatter":{"date":"2019-09-21","title":"How Unreal Engine C++ Cast<T> function works?"}},"next":null}},"staticQueryHashes":["1778280346"]}