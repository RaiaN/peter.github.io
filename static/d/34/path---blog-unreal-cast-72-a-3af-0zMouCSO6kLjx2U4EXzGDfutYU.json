{"data":{"site":{"siteMetadata":{"author":"Peter Leontev","title":"Peter Leontev - Generalist Programmer","disqusID":"peterleontev"}},"mdx":{"id":"a5ce4c62-fe13-556a-b7b8-d3384b00202e","excerpt":"When you write  Cast<T > (SomeObject)  in Unreal C++, is it any different to dynamic_cast<T >  in plain C++? Answer is definitely yes so lets figure out howâ€¦","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How Cast function works in Unreal Engine 4?\",\n  \"date\": \"2019-09-20\",\n  \"description\": \"And is it any better than dynamic_cast?\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When you write \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Cast<T\", \">\", \"(SomeObject)\"), \" in Unreal C++, is it any different to dynamic_cast<T\", \">\", \" in plain C++? Answer is definitely yes so lets figure out how \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Cast\"), \" function works under hood!\"), mdx(\"p\", null, \"Unreal Engine C++ provides a built-in support for \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection\"\n  }), mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"reflection system\")), \" which gives one a way to perform type-safe up-  and down-casts without a need to use dynamic_cast<T\", \">\", \". Lets look at the function \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Cast<T\", \">\"), \": \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename To, typename From>\\nFORCEINLINE To* Cast(From* Src)\\n{\\n    return TCastImpl<From, To>::DoCast(Src);\\n}\\n\")), mdx(\"p\", null, \"As you can see, it simply uses some template structure called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TCastImpl\"), \" to convert a pointer of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"From\"), \" class to the pointer of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"To\"), \" class. Indeed, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TCastImpl\"), \" is where all the magic happens.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename From, typename To, ECastType CastType = TGetCastType<From, To>::Value>\\nstruct TCastImpl\\n{\\n    // This is the cast flags implementation\\n    FORCEINLINE static To* DoCast( UObject* Src )\\n    {\\n        return Src && Src->GetClass()->HasAnyCastFlag(TCastFlags<To>::Value) ? (To*)Src : nullptr;\\n    }\\n\\n    FORCEINLINE static To* DoCastCheckedWithoutTypeCheck( UObject* Src )\\n    {\\n        return (To*)Src;\\n    }\\n};\\n\")), mdx(\"p\", null, \"Given a valid pointer of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"From\"), \" class \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DoCast\"), \" uses C-style cast to convert it to the pointer of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"To\"), \" class, otherwise \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DoCast\"), \" returns nullptr (note that dynamic_cast<T\", \">\", \" is neved considered when using a C-style cast). This way both const and non-const pointers are handled correctly since C-style casts tries \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"const_cast\"), \" first and only then \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"static_cast\"), \". So far, so good. \"), mdx(\"p\", null, \"There are several questions to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DoCast\"), \" implementation. The first is how efficient \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"HasAnyCastFlag()\"), \" function? It turns out that this function simply checks bitmask. Also notice that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FORCEINLINE\"), \" is used (which is actually \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.microsoft.com/en-us/cpp/cpp/inline-functions-cpp?redirectedfrom=MSDN&view=vs-2019\"\n  }), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"__forceinline\")), \" keyword that is supported by MSVS compiler) to potentially remove the function call cost.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"FORCEINLINE bool HasAnyCastFlag(EClassCastFlags FlagToCheck) const\\n{\\n    return (ClassCastFlags&FlagToCheck) != 0;\\n}\\n\")), mdx(\"p\", null, \"Also, it is important to remember that the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Cast\"), \" function should not be called too often. Ideally, your code should not call the Cast function at all!\"), mdx(\"p\", null, \"The second question is related to C-style cast. Will \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"reinterpret_cast\"), \" be used in some cases? The answer is not because that is where Unreal \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"reflection system\"), \" comes into play. What it does is simply stores an additional information about the class in its CDO (Class Default Object). More specifically, it is either corresponding \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UStruct\"), \" object or  \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ClassCastFlags\"), \" or both. Using this reflection information in runtime one can determine whether two classes belong to the same hierarchy and if they are not then nullptr is returned. \"), mdx(\"p\", null, \"Now lets return to the structure \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TCastImpl\"), \". It turns out that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TCastImpl::DoCast\"), \" function above won't be called in the default configuration of UE4 C++ module. Why? This is all due to how the template structure \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TGetCastType\"), \" works (below).\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename From, typename To, bool bFromInterface = TIsIInterface<From>::Value, bool bToInterface = TIsIInterface<To>::Value, EClassCastFlags CastClass = TCastFlags<To>::Value>\\nstruct TGetCastType\\n{\\n#if USTRUCT_FAST_ISCHILDOF_IMPL == USTRUCT_ISCHILDOF_STRUCTARRAY\\n    static const ECastType Value = ECastType::UObjectToUObject;\\n#else\\n    static const ECastType Value = ECastType::FromCastFlags;\\n#endif\\n};\\n\\ntemplate <typename From, typename To                           > struct TGetCastType<From, To, false, false, CASTCLASS_None> { static const ECastType Value = ECastType::UObjectToUObject;     };\\ntemplate <typename From, typename To                           > struct TGetCastType<From, To, false, true , CASTCLASS_None> { static const ECastType Value = ECastType::UObjectToInterface;   };\\ntemplate <typename From, typename To, EClassCastFlags CastClass> struct TGetCastType<From, To, true,  false, CastClass     > { static const ECastType Value = ECastType::InterfaceToUObject;   };\\ntemplate <typename From, typename To, EClassCastFlags CastClass> struct TGetCastType<From, To, true,  true , CastClass     > { static const ECastType Value = ECastType::InterfaceToInterface; };\\n\")), mdx(\"p\", null, \"As you can see there are checks for the third and the forth template arguments of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TGetCastType\"), \" to be an interface. This way one of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TGetCastType\"), \" specializations will be chosen and then using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ECastType\"), \" value the specialization of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TCastImpl\"), \" structure will be selected  to perform the cast itself (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UObject to UObject\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UObject to Interface\"), \" and so on).\"));\n}\nMDXContent.isMDXComponent = true;"},"frontmatter":{"title":"How Cast function works in Unreal Engine 4?","date":"September 20, 2019","description":"And is it any better than dynamic_cast?"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/unreal_cast/","previous":{"fields":{"slug":"/blog/level_streaming_optimization/"},"frontmatter":{"date":"2019-06-19","title":"Level Streaming And Garbage Collection Optimization Tweaks In Unreal Engine 4"}},"next":null}}