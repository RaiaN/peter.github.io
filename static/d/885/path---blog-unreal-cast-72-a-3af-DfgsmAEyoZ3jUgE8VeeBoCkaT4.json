{"data":{"site":{"siteMetadata":{"author":"Peter Leontev","title":"Peter Leontev - Generalist Programmer","disqusID":"peterleontev"}},"mdx":{"id":"a5ce4c62-fe13-556a-b7b8-d3384b00202e","excerpt":"Unreal C++  Cast<T > (SomeObject)  allows to dynamically cast an object type-safely. But what is difference between  Cast<T >  and  dynamic_cast<T >  in plain Câ€¦","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How Cast function works in Unreal Engine 4?\",\n  \"date\": \"2019-09-21\",\n  \"description\": \"Runtime cost, caveats and more\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Unreal C++ \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Cast<T\", \">\", \"(SomeObject)\"), \" allows to dynamically cast an object type-safely. But what is difference between \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Cast<T\", \">\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"dynamic_cast<T\", \">\"), \" in plain C++? Lets figure that out!\"), mdx(\"p\", null, \"Unreal Engine C++ provides a built-in support for \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection\"\n  }), mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"reflection system\")), \" which gives one a way to perform type-safe up- and down-casts without a need to use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"static_cast<T\", \">\"), \" or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"dynamic_cast<T\", \">\"), \". Lets look at the function \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Cast<T\", \">\"), \": \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename To, typename From>\\nFORCEINLINE To* Cast(From* Src)\\n{\\n    return TCastImpl<From, To>::DoCast(Src);\\n}\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Cast\"), \" function simply uses some template structure called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TCastImpl\"), \" to convert the pointer of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"From\"), \" class to the pointer of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"To\"), \" class. Indeed, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TCastImpl\"), \" is where all the magic happens.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename From, typename To, ECastType CastType = TGetCastType<From, To>::Value>\\nstruct TCastImpl\\n{\\n    // This is the cast flags implementation\\n    FORCEINLINE static To* DoCast( UObject* Src )\\n    {\\n        return Src && Src->GetClass()->HasAnyCastFlag(TCastFlags<To>::Value) ? (To*)Src : nullptr;\\n    }\\n\\n    FORCEINLINE static To* DoCastCheckedWithoutTypeCheck( UObject* Src )\\n    {\\n        return (To*)Src;\\n    }\\n};\\n\")), mdx(\"p\", null, \"Given the valid pointer of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"From\"), \" class \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DoCast\"), \" uses C-style cast to convert it to the pointer of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"To\"), \" class, otherwise nullptr is returned (note that dynamic_cast<T\", \">\", \" is neved considered when using a C-style cast). This way both const and non-const pointers are handled correctly since C-style casts tries \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"const_cast\"), \" first and only then \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"static_cast\"), \". So far, so good. \"), mdx(\"p\", null, \"There are several questions about \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DoCast\"), \" implementation. The first is how efficient \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"HasAnyCastFlag()\"), \" function? It turns out that this function simply checks bitmask. Also notice that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FORCEINLINE\"), \" is used (which is actually \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.microsoft.com/en-us/cpp/cpp/inline-functions-cpp?redirectedfrom=MSDN&view=vs-2019\"\n  }), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"__forceinline\")), \" keyword that is supported by MSVS compiler) to potentially remove the function call cost.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"FORCEINLINE bool HasAnyCastFlag(EClassCastFlags FlagToCheck) const\\n{\\n    return (ClassCastFlags&FlagToCheck) != 0;\\n}\\n\")), mdx(\"p\", null, \"Also, it is important to remember that the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Cast\"), \" function should not be called too often. Ideally, the game code should not call the Cast function at all!\"), mdx(\"p\", null, \"The second question is related to C-style cast. Will \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"reinterpret_cast\"), \" be used in some cases? The answer is not because that is where Unreal \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"reflection system\"), \" comes into play. What it does is simply stores an additional information about the class in its CDO (Class Default Object). More specifically, it is either corresponding \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UStruct\"), \" object or  \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ClassCastFlags\"), \" or both. Using this reflection information in runtime one can determine whether two classes belong to the same hierarchy and if they are not then nullptr is returned. \"), mdx(\"p\", null, \"Now lets return to the structure \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TCastImpl\"), \". It turns out that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TCastImpl::DoCast\"), \" function above won't be called in the default configuration of UE4 C++ module. Why? This is all due to how the template structure \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TGetCastType\"), \" works (below).\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename From, typename To, bool bFromInterface = TIsIInterface<From>::Value, bool bToInterface = TIsIInterface<To>::Value, EClassCastFlags CastClass = TCastFlags<To>::Value>\\nstruct TGetCastType\\n{\\n#if USTRUCT_FAST_ISCHILDOF_IMPL == USTRUCT_ISCHILDOF_STRUCTARRAY\\n    static const ECastType Value = ECastType::UObjectToUObject;\\n#else\\n    static const ECastType Value = ECastType::FromCastFlags;\\n#endif\\n};\\n\\ntemplate <typename From, typename To                           > struct TGetCastType<From, To, false, false, CASTCLASS_None> { static const ECastType Value = ECastType::UObjectToUObject;     };\\ntemplate <typename From, typename To                           > struct TGetCastType<From, To, false, true , CASTCLASS_None> { static const ECastType Value = ECastType::UObjectToInterface;   };\\ntemplate <typename From, typename To, EClassCastFlags CastClass> struct TGetCastType<From, To, true,  false, CastClass     > { static const ECastType Value = ECastType::InterfaceToUObject;   };\\ntemplate <typename From, typename To, EClassCastFlags CastClass> struct TGetCastType<From, To, true,  true , CastClass     > { static const ECastType Value = ECastType::InterfaceToInterface; };\\n\")), mdx(\"p\", null, \"The third and the forth template arguments of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TGetCastType\"), \" are checked to be an interface. This way one of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TGetCastType\"), \" specializations will be chosen and then using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ECastType\"), \" value the specialization of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TCastImpl\"), \" structure will be selected to perform the cast itself (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UObject to UObject\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UObject to Interface\"), \" and so on).\"), mdx(\"p\", null, \"Lets consider one of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TCastImpl\"), \" specializations that handles \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UObject to UObject\"), \" cast.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename From, typename To>\\nstruct TCastImpl<From, To, ECastType::UObjectToUObject>\\n{\\n    FORCEINLINE static To* DoCast( UObject* Src )\\n    {\\n        return Src && Src->IsA<To>() ? (To*)Src : nullptr;\\n    }\\n\\n    FORCEINLINE static To* DoCastCheckedWithoutTypeCheck( UObject* Src )\\n    {\\n        return (To*)Src;\\n    }\\n};\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DoCast()\"), \" calls \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IsA()\"), \" function to determine whether passed object is of the specified type. It that is true then C-style cast is applied. \"), mdx(\"p\", null, \"What is the performance cost of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IsA()\"), \" function call in the default configuration of UE4 C++ module? It turns out that the performance heavy part of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IsA()\"), \" function is the call to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IsChildOf()\"), \" function that has two quite different implementations.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"    /** Returns true if this struct either is SomeBase, or is a child of SomeBase. This will not crash on null structs */\\n#if USTRUCT_FAST_ISCHILDOF_COMPARE_WITH_OUTERWALK || USTRUCT_FAST_ISCHILDOF_IMPL == USTRUCT_ISCHILDOF_OUTERWALK\\n    bool IsChildOf( const UStruct* SomeBase ) const;\\n#else\\n    bool IsChildOf(const UStruct* SomeBase) const\\n    {\\n        return (SomeBase ? IsChildOfUsingStructArray(*SomeBase) : false);\\n    }\\n#endif\\n\")), mdx(\"p\", null, \"When \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UE_EDITOR\"), \" = 1 the preprocessor directive \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"USTRUCT_FAST_ISCHILDOF_IMPL = USTRUCT_ISCHILDOF_OUTERWALK\"), \" and that means the following implementation of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IsChildOf\"), \" function is going to be used:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"#if USTRUCT_FAST_ISCHILDOF_COMPARE_WITH_OUTERWALK || USTRUCT_FAST_ISCHILDOF_IMPL == USTRUCT_ISCHILDOF_OUTERWALK\\nbool UStruct::IsChildOf( const UStruct* SomeBase ) const\\n{\\n    if (SomeBase == nullptr)\\n    {\\n        return false;\\n    }\\n\\n    bool bOldResult = false;\\n    for ( const UStruct* TempStruct=this; TempStruct; TempStruct=TempStruct->GetSuperStruct() )\\n    {\\n        if ( TempStruct == SomeBase )\\n        {\\n            bOldResult = true;\\n            break;\\n        }\\n    }\\n\\n#if USTRUCT_FAST_ISCHILDOF_IMPL == USTRUCT_ISCHILDOF_STRUCTARRAY\\n    const bool bNewResult = IsChildOfUsingStructArray(*SomeBase);\\n#endif\\n\\n#if USTRUCT_FAST_ISCHILDOF_COMPARE_WITH_OUTERWALK\\n    ensureMsgf(bOldResult == bNewResult, TEXT(\\\"New cast code failed\\\"));\\n#endif\\n\\n    return bOldResult;\\n}\\n#endif\\n\")), mdx(\"p\", null, \"The most important part here is inner \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop that tries to find a pair of equal reflection structs between given class and passed one. If such a pair is found then one class is a child of another. Runtime cost of such \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IsChildOf\"), \" function is equal to the depth of the inheritance tree, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"O(Depth(InheritanceTree))\"), \".\"), mdx(\"p\", null, \"When \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UE_EDITOR\"), \" = 1 the preprocessor directive \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"USTRUCT_FAST_ISCHILDOF_IMPL = USTRUCT_ISCHILDOF_STRUCTARRAY\"), \" and that means the following implementation of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IsChildOf\"), \" function is going to be used:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"bool IsChildOf(const UStruct* SomeBase) const\\n{\\n    return (SomeBase ? IsChildOfUsingStructArray(*SomeBase) : false);\\n}\\n\\n#if USTRUCT_FAST_ISCHILDOF_IMPL == USTRUCT_ISCHILDOF_STRUCTARRAY\\nclass FStructBaseChain\\n{\\nprotected:\\n    COREUOBJECT_API FStructBaseChain();\\n    COREUOBJECT_API ~FStructBaseChain();\\n\\n    // Non-copyable\\n    FStructBaseChain(const FStructBaseChain&) = delete;\\n    FStructBaseChain& operator=(const FStructBaseChain&) = delete;\\n\\n    COREUOBJECT_API void ReinitializeBaseChainArray();\\n\\n    // this is O(1) implementation of IsChildOf\\n    FORCEINLINE bool IsChildOfUsingStructArray(const FStructBaseChain& Parent) const\\n    {\\n        int32 NumParentStructBasesInChainMinusOne = Parent.NumStructBasesInChainMinusOne;\\n        return NumParentStructBasesInChainMinusOne <= NumStructBasesInChainMinusOne && StructBaseChainArray[NumParentStructBasesInChainMinusOne] == &Parent;\\n    }\\n\\nprivate:\\n    FStructBaseChain** StructBaseChainArray;\\n    int32 NumStructBasesInChainMinusOne;\\n\\n    friend class UStruct;\\n};\\n#endif\\n\")), mdx(\"p\", null, \"The function \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IsChildOfUsingStructArray\"), \" uses \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"StructBaseChainArray\"), \" array as a storage for reflection data or structs of the class.\"), mdx(\"p\", null, \"This leads to the conclusion that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"Cast<T\", \">\"), \" runtime cost\"), \" is:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"* Linear,   O(Depth(InheritanceTree)), in editor environment     (UE_EDITOR = 1).\\n* Constant, O(1),                      in non-editor environment (UE_EDITOR = 0).\\n\")), mdx(\"p\", null, \"How \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Cast<T\", \">\"), \" supports both up- and down-casts? Pointers of different classes can point to the same object but that does not change their reflection data or structs (and indeed the content of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"StructBaseChainArray\"), \") so \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IsA\"), \" will always find a pair of equal reflection structs given both classes belong to the same class hierarchy.\"), mdx(\"p\", null, \"Now, what is the point of using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Cast<T\", \">\"), \" if one can go for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"static_cast\"), \" to do exactly the same? The answer is safety. If one mismatches the class types or change the inheritance tree the result of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Cast<T\", \">\"), \" will be nullptr. However, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"static_cast\"), \" may perform cast and return some invalid pointer. Bad!\"), mdx(\"p\", null, \"To sum up, below are the key things about Cast<T\", \">\", \" in Unreal C++:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"* *Cast<T\\\\>* for *UObjects* has to be used due to type safety (thanks to UE4 reflection data).\\n* *Cast<T\\\\>* runtime cost is *O(Depth(InheritanceTree))* in editor environment and *O(1) or constant* in non-editor environment.\\n* *Cast<T\\\\>* does not use *dynamic_cast* thanks to UE4 reflection data.\\n\")));\n}\nMDXContent.isMDXComponent = true;"},"frontmatter":{"title":"How Cast function works in Unreal Engine 4?","date":"September 21, 2019","description":"Runtime cost, caveats and more"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/unreal_cast/","previous":{"fields":{"slug":"/blog/level_streaming_optimization/"},"frontmatter":{"date":"2019-06-19","title":"Level Streaming And Garbage Collection Optimization Tweaks In Unreal Engine 4"}},"next":null}}