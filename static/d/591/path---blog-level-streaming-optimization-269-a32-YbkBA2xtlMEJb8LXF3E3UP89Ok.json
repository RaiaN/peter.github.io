{"data":{"site":{"siteMetadata":{"author":"Peter Leontev","title":"Peter Leontev - Generalist Programmer","disqusID":"peterleontev"}},"mdx":{"id":"97560010-bbfc-59c3-ab0e-205c49b8d9d3","excerpt":"Unreal Engine 4 Level Streaming is very useful tool if you want to give yourself a freedom while creating an environment. Of course, that is not true in generalâ€¦","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Quick & Dirty Level Streaming Optimizations In Unreal Engine 4\",\n  \"date\": \"2019-06-01T14-00\",\n  \"description\": \"Or how to save a situation?\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Unreal Engine 4 Level Streaming is very useful tool if you want to give yourself a freedom while creating an environment. Of course, that is not true in general and also comes with cost. Sometimes that cost is just too high and chances are it will kill your project.\"), mdx(\"p\", null, \"However, that is not an optimistic way of thinking. You can still do a ton of optimizations or, lets call them correctly, some streaming tweaks to save the day. Lets dive in.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"s.UseBackgroundLevelStreaming\")), mdx(\"p\", null, \"Open LevelStreaming.cpp and find the function UpdateStreamingState and the following lines:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"// 1\\nbool bBlockOnLoad = (bShouldBlockOnLoad || ShouldBeAlwaysLoaded());\\n// 2\\nbBlockOnLoad |= (!GUseBackgroundLevelStreaming || !World->IsGameWorld());\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"bShouldBlockOnLoad\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ShouldBeAlwaysLoaded()\"), \" are traits of LevelStreaming object that control whether we have to block this thread while loading the level or not (first trait can be changed via World Composition level settings)\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"bBlockOnLoad\"), \" is only true (i.e. we block thread on level load) when world is not any kind of game world and we do not use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s.UseBackgroundLevelStreaming\"), \". \"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"s.GLevelStreamingComponentsRegistrationGranularity\")), mdx(\"p\", null, \"Open World.cpp and find the function \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"AddToWorld\"), \". Documentation clearly states that this function associates the passed in level with the world. Most importantly, the work to make the level visible is spread across several frames and this function has to be called till it returns true for the level to be visible/associated with the world and no longer be in a limbo state.\"), mdx(\"p\", null, \"But which kind of work will be spread across several frames? \"), mdx(\"p\", null, \"Lets look at the following piece of code from \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"AddToWorld\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"int32 NumComponentsToUpdate = GLevelStreamingComponentsRegistrationGranularity;\\ndo\\n{\\n    Level->IncrementalUpdateComponents( (!IsGameWorld() || IsRunningCommandlet()) ? 0 : NumComponentsToUpdate, bRerunConstructionScript );\\n}\\nwhile( !Level->bAreComponentsCurrentlyRegistered && (!bConsiderTimeLimit || !IsTimeLimitExceeded( TEXT(\\\"updating components\\\"), StartTime, Level, TimeLimit )));\\n\\n// We are done once all components are attached.\\nLevel->bAlreadyUpdatedComponents = Level->bAreComponentsCurrentlyRegistered;\\nbExecuteNextStep = Level->bAreComponentsCurrentlyRegistered && (!bConsiderTimeLimit || !IsTimeLimitExceeded(TEXT(\\\"updating components\\\"), StartTime, Level, TimeLimit));\\n\")), mdx(\"p\", null, \"As we can see \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s.GLevelStreamingComponentsRegistrationGranularity\"), \" is just a number of components to update during execution of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"AddToWorld\"), \".\"));\n}\nMDXContent.isMDXComponent = true;"},"frontmatter":{"title":"Quick & Dirty Level Streaming Optimizations In Unreal Engine 4","date":"June 01, 2019","description":"Or how to save a situation?"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/level_streaming_optimization/","previous":{"fields":{"slug":"/blog/c++_pointers/"},"frontmatter":{"date":"2019-04-21T16-00","title":"Handling invalid Unreal Engine 4 C++ pointers"}},"next":null}}