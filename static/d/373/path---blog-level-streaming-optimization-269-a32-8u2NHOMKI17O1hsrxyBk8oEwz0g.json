{"data":{"site":{"siteMetadata":{"author":"Peter Leontev","title":"Peter Leontev - Generalist Programmer","disqusID":"peterleontev"}},"mdx":{"id":"97560010-bbfc-59c3-ab0e-205c49b8d9d3","excerpt":"Unreal Engine 4 Level Streaming is very useful tool if you want to give yourself a freedom while creating an environment. Of course, that is not true in generalâ€¦","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Level Streaming And Garbage Collection Optimization Tweaks In Unreal Engine 4\",\n  \"date\": \"2019-06-01T14-00\",\n  \"description\": \"Or why am I experiencing hitches during the game?\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Unreal Engine 4 Level Streaming is very useful tool if you want to give yourself a freedom while creating an environment. Of course, that is not true in general and also comes with cost. Sometimes that cost is just too high and chances are it will kill your project.\"), mdx(\"p\", null, \"However, that is not an optimistic way of thinking. You can still do a ton of optimizations or, lets call them correctly, some streaming tweaks to save the day. Lets dive in.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"s.UseBackgroundLevelStreaming\")), mdx(\"p\", null, \"Open \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"LevelStreaming.cpp\"), \" and find the function \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UpdateStreamingState\"), \" and the following lines:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"bool bBlockOnLoad = (bShouldBlockOnLoad || ShouldBeAlwaysLoaded());\\n//...\\nbBlockOnLoad |= (!GUseBackgroundLevelStreaming || !World->IsGameWorld());\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"bShouldBlockOnLoad\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ShouldBeAlwaysLoaded()\"), \" are traits of LevelStreaming object that control whether we have to block this thread while loading the level or not (first trait can be changed via World Composition level settings).\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"bBlockOnLoad\"), \" is only true (i.e. we block thread on level load) when world is not any kind of game world and we do not use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s.UseBackgroundLevelStreaming\"), \". \"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"s.GLevelStreamingComponentsRegistrationGranularity\")), mdx(\"p\", null, \"Open \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"World.cpp\"), \" and find the function \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"AddToWorld\"), \". Documentation clearly states that this function associates the passed in level with the world. Most importantly, the work to make the level visible is spread across several frames and this function has to be called till it returns true for the level to be visible/associated with the world and no longer be in a limbo state.\"), mdx(\"p\", null, \"But which kind of work will be spread across several frames? \"), mdx(\"p\", null, \"Lets look at the following piece of code from \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"AddToWorld\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"int32 NumComponentsToUpdate = GLevelStreamingComponentsRegistrationGranularity;\\ndo\\n{\\n    Level->IncrementalUpdateComponents( (!IsGameWorld() || IsRunningCommandlet()) ? 0 : NumComponentsToUpdate, bRerunConstructionScript );\\n}\\nwhile( !Level->bAreComponentsCurrentlyRegistered && (!bConsiderTimeLimit || !IsTimeLimitExceeded( TEXT(\\\"updating components\\\"), StartTime, Level, TimeLimit )));\\n\\n// We are done once all components are attached.\\nLevel->bAlreadyUpdatedComponents = Level->bAreComponentsCurrentlyRegistered;\\nbExecuteNextStep = Level->bAreComponentsCurrentlyRegistered && (!bConsiderTimeLimit || !IsTimeLimitExceeded(TEXT(\\\"updating components\\\"), StartTime, Level, TimeLimit));\\n\")), mdx(\"p\", null, \"As we can see \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s.GLevelStreamingComponentsRegistrationGranularity\"), \" is just a number of components to update during execution of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"AddToWorld\"), \". So, each time we call \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"AddToWorld\"), \" the execution will be stopped as soon as either time limit is exceeded or all level components have been registered. \"), mdx(\"p\", null, \"Besides that, there is the condition \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"(!IsGameWorld() || IsRunningCommandlet())\"), \" that says we are only going to register NumComponentsToUpdate components if we are not in commandlet mode and current world is the game world. \"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"s.LevelStreamingActorsUpdateTimeLimit\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"s.PriorityLevelStreamingActorsUpdateExtraTime\")), mdx(\"p\", null, \"As you could notice above there is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TimeLimit\"), \" term and, what is really important, it is measured in seconds.\"), mdx(\"p\", null, \"By default \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TimeLimit\"), \" for AddToWorld execution is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"LevelStreamingActorsUpdateTimeLimit\"), \" value. However, if high priority load has to happen (which is the topic for separate article) then we just add value of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"PriorityLevelStreamingActorsUpdateExtraTime\"), \" and as result: \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"TimeLimit = LevelStreamingActorsUpdateTimeLimit [+ PriorityLevelStreamingActorsUpdateExtraTime if HighPriorityLoad]\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TimeLimit\"), \" is checked after almost each step in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"AddToWorld\"), \" function: \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"* Applying level transform to level actors (FLevelUtils::ApplyLevelTransform)\\n* Applying world offset to level (ULevel::ApplyWorldOffset)\\n* Updating level components (ULevel::IncrementalUpdateComponents)\\n* Initializing level actors (ULevel::InitializeNetworkActors)\\n* Routing various initialization functions (ULevel::RouteActorInitialize())\\n* Sorting actor list (ULevel::SortActorList)\\n\")), mdx(\"p\", null, \"If you increase the value of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s.LevelStreamingActorsUpdateTimeLimit\"), \" too much then you will see a lot of hitches if your levels are content heavy. However, if value is too small then level won't be loaded in time (before player sees it) and it can cause different set of problems (for example, player will fall down under the world) so tweak this value carefully.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"s.LevelStreamingComponentsUnregistrationGranularity\")), mdx(\"p\", null, \"This option is very similar to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s.GLevelStreamingComponentsRegistrationGranularity\"), \" except that it is used in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"RemoveFromWorld\"), \" (also in World.cpp).\"), mdx(\"p\", null, \"Look at the code below:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"int32 NumComponentsToUnregister = GLevelStreamingComponentsUnregistrationGranularity;\\ndo\\n{\\n    if (Level->IncrementalUnregisterComponents(NumComponentsToUnregister))\\n    {\\n        // We're done, so the level can be removed\\n        CurrentLevelPendingInvisibility = nullptr;\\n        bFinishRemovingLevel = true;\\n        break;\\n    }\\n} while (!IsTimeLimitExceeded(TEXT(\\\"unregistering components\\\"), StartTime, Level, GLevelStreamingUnregisterComponentsTimeLimit));\\n\")), mdx(\"p\", null, \"Take note that unregistration procedure is timesliced only when level does not block thread while loading and corresponding world is a game world. This is controlled by \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"RemoveFromWorld\"), \" second input parameter, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"bAllowIncrementalRemoval\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GLevelStreamingForceGCAfterLevelStreamedOut\")), mdx(\"p\", null, \"Forced Garbage collection can easily make your game hitch since, well, it does a lot of stuff under the hood (from checking references to freeing memory if needed).\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GLevelStreamingForceGCAfterLevelStreamedOut\"), \" is used in two separate contexts. First one is below:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"// In case more levels has been requested to unload, force GC on next tick \\nif (GLevelStreamingForceGCAfterLevelStreamedOut != 0)\\n{\\n    if (NumLevelsPendingPurge < FLevelStreamingGCHelper::GetNumLevelsPendingPurge())\\n    {\\n        GEngine->ForceGarbageCollection(true); \\n    }\\n}\\n\")));\n}\nMDXContent.isMDXComponent = true;"},"frontmatter":{"title":"Level Streaming And Garbage Collection Optimization Tweaks In Unreal Engine 4","date":"June 01, 2019","description":"Or why am I experiencing hitches during the game?"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/level_streaming_optimization/","previous":{"fields":{"slug":"/blog/c++_pointers/"},"frontmatter":{"date":"2019-04-21T16-00","title":"Handling invalid Unreal Engine 4 C++ pointers"}},"next":null}}